import { query } from '../database';
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

interface ActiveDeployment {
  slug: string;
  port: number;
  project_id: string;
}

/**
 * Nginx Config Service
 * Manages dynamic nginx configuration based on active deployments
 * Allows routing subdomain.gilgal.tech to correct container ports
 */
export class NginxConfigService {
  private static readonly CONFIG_PATH = '/etc/nginx/sites-available/gilgal.tech';
  private static readonly DOMAIN = 'gilgal.tech';

  /**
   * Get all active deployments with their container ports
   * Only returns deployments with status=success and not deleted
   */
  static async getActiveDeployments(): Promise<ActiveDeployment[]> {
    try {
      const result = await query(
        `
        SELECT 
          p.slug,
          d.container_port as port,
          p.id as project_id
        FROM deployments d
        JOIN projects p ON d.project_id = p.id
        WHERE d.status = 'success' 
          AND d.container_port IS NOT NULL
          AND p.deleted_at IS NULL
          AND d.id = (
            -- Get latest successful deployment for each project
            SELECT id FROM deployments d2 
            WHERE d2.project_id = p.id 
              AND d2.status = 'success'
            ORDER BY d2.deployed_at DESC 
            LIMIT 1
          )
        ORDER BY p.slug ASC
        `,
        []
      );

      return result.rows;
    } catch (error) {
      console.error('[NginxConfig] Error fetching active deployments:', error);
      throw error;
    }
  }

  /**
   * Generate nginx configuration from active deployments
   * Creates dynamic routing for subdomains
   */
  static async generateNginxConfig(): Promise<string> {
    const deployments = await this.getActiveDeployments();

    // Build upstream definitions for each project
    const upstreamBlocks = deployments
      .map(
        (dep) => `
  upstream ${dep.project_id} {
    server localhost:${dep.port};
  }
`
      )
      .join('\n');

    // Build server blocks for each subdomain
    const serverBlocks = deployments
      .map(
        (dep) => `
server {
    listen 80;
    server_name ${dep.slug}.${this.DOMAIN};

    location / {
        proxy_pass http://${dep.project_id};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}
`
      )
      .join('\n');

    // Main domain falls back to first deployment or shows info page
    const mainDomainBlock = deployments.length > 0
      ? `
server {
    listen 80;
    server_name ${this.DOMAIN} www.${this.DOMAIN};

    location / {
        proxy_pass http://${deployments[0].project_id};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
`
      : `
server {
    listen 80;
    server_name ${this.DOMAIN} www.${this.DOMAIN};

    location / {
        return 200 'Gilgal PaaS - No deployments yet. Deploy your first project!';
        add_header Content-Type text/plain;
    }
}
`;

    const config = `# Auto-generated by Gilgal PaaS
# DO NOT EDIT MANUALLY - changes will be overwritten on deployment
# Generated: ${new Date().toISOString()}

${upstreamBlocks}

${serverBlocks}

${mainDomainBlock}
`;

    return config;
  }

  /**
   * Write nginx config to file and reload nginx
   */
  static async applyNginxConfig(): Promise<void> {
    try {
      console.log('[NginxConfig] Generating nginx configuration...');

      const config = await this.generateNginxConfig();

      // For development/non-root, just log the config
      // In production on VM, this would write to /etc/nginx/sites-available/gilgal.tech
      console.log('[NginxConfig] Generated config:');
      console.log(config);

      // Try to write config if running with permissions
      try {
        fs.writeFileSync(this.CONFIG_PATH, config, 'utf-8');
        console.log(`[NginxConfig] Config written to ${this.CONFIG_PATH}`);

        // Test nginx configuration
        try {
          execSync('sudo nginx -t', { stdio: 'pipe' });
          console.log('[NginxConfig] Nginx config validated');

          // Reload nginx
          execSync('sudo systemctl reload nginx', { stdio: 'pipe' });
          console.log('[NginxConfig] Nginx reloaded successfully');
        } catch (error) {
          console.warn('[NginxConfig] Could not reload nginx (may require sudo):', error);
          // Continue anyway - config is written even if reload fails
        }
      } catch (error) {
        console.warn('[NginxConfig] Could not write config file (may require sudo):', error);
        // Log the config that would have been written for manual setup
        console.log('[NginxConfig] Manually copy this to /etc/nginx/sites-available/gilgal.tech:');
        console.log(config);
      }
    } catch (error) {
      console.error('[NginxConfig] Failed to apply nginx config:', error);
      throw error;
    }
  }
}
