import { query } from '../database';
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

interface ActiveDeployment {
  slug: string;
  port: number;
  project_id: string;
}

/**
 * Nginx Config Service
 * Manages dynamic nginx configuration based on active deployments
 * Allows routing subdomain.gilgal.tech to correct container ports
 */
export class NginxConfigService {
  private static readonly CONFIG_PATH = '/etc/nginx/sites-available/gilgal.tech';
  private static readonly DOMAIN = 'gilgal.tech';

  /**
   * Get all active deployments with their container ports
   * Only returns deployments with status=success and not deleted
   */
  static async getActiveDeployments(): Promise<ActiveDeployment[]> {
    try {
      const result = await query(
        `
        SELECT 
          p.slug,
          d.container_port as port,
          p.id as project_id
        FROM deployments d
        JOIN projects p ON d.project_id = p.id
        WHERE d.status = 'success' 
          AND d.container_port IS NOT NULL
          AND p.deleted_at IS NULL
          AND d.id = (
            -- Get latest successful deployment for each project
            SELECT id FROM deployments d2 
            WHERE d2.project_id = p.id 
              AND d2.status = 'success'
            ORDER BY d2.deployed_at DESC 
            LIMIT 1
          )
        ORDER BY p.slug ASC
        `,
        []
      );

      return result.rows;
    } catch (error) {
      console.error('[NginxConfig] Error fetching active deployments:', error);
      throw error;
    }
  }

  /**
   * Generate nginx configuration from active deployments
   * Creates dynamic routing for subdomains
   * Always includes main routes: landing, docs, api
   */
  static async generateNginxConfig(): Promise<string> {
    const deployments = await this.getActiveDeployments();

    // Main upstreams (always present)
    const mainUpstreams = `
  upstream landing {
    server localhost:8001;
  }

  upstream docs {
    server localhost:8002;
  }

  upstream api {
    server localhost:3000;
  }
`;

    // Build upstream definitions for user deployments
    const userUpstreams = deployments
      .map(
        (dep) => `
  upstream ${dep.project_id} {
    server localhost:${dep.port};
  }
`
      )
      .join('\n');

    // Main routes (always present)
    const mainRoutes = `
server {
    listen 80;
    server_name ${this.DOMAIN} www.${this.DOMAIN};
    location / {
        proxy_pass http://landing;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

server {
    listen 80;
    server_name docs.${this.DOMAIN};
    location / {
        proxy_pass http://docs;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

server {
    listen 80;
    server_name api.${this.DOMAIN};
    location / {
        proxy_pass http://api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
`;

    // Build server blocks for user deployments
    const userServerBlocks = deployments
      .map(
        (dep) => `
server {
    listen 80;
    server_name ${dep.slug}.${this.DOMAIN};

    location / {
        proxy_pass http://${dep.project_id};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}
`
      )
      .join('\n');

    const config = `# Auto-generated by Gilgal PaaS
# DO NOT EDIT MANUALLY - changes will be overwritten on deployment
# Generated: ${new Date().toISOString()}

${mainUpstreams}
${userUpstreams}

${mainRoutes}
${userServerBlocks}
`;

    return config;
  }

  /**
   * Write nginx config to file and reload nginx
   */
  static async applyNginxConfig(): Promise<void> {
    try {
      console.log('[NginxConfig] Generating nginx configuration...');

      const config = await this.generateNginxConfig();

      // For development/non-root, just log the config
      // In production on VM, this would write to /etc/nginx/sites-available/gilgal.tech
      console.log('[NginxConfig] Generated config:');
      console.log(config);

      // Try to write config using temp file (avoids shell escaping issues)
      try {
        const tempPath = `/tmp/gilgal-${Date.now()}.nginx.conf`;
        fs.writeFileSync(tempPath, config, 'utf-8');

        // Move temp file to nginx directory with sudo
        execSync(`sudo mv ${tempPath} ${this.CONFIG_PATH}`, { stdio: 'pipe' });
        console.log(`[NginxConfig] Config written to ${this.CONFIG_PATH}`);

        // Test nginx configuration
        try {
          execSync('sudo nginx -t', { stdio: 'pipe' });
          console.log('[NginxConfig] Nginx config validated');

          // Reload nginx
          execSync('sudo systemctl reload nginx', { stdio: 'pipe' });
          console.log('[NginxConfig] Nginx reloaded successfully');
        } catch (error) {
          console.warn('[NginxConfig] Could not reload nginx:', error);
          // Continue anyway - config is written even if reload fails
        }
      } catch (error) {
        console.warn('[NginxConfig] Could not write config file:', error);
        // Log the config that would have been written for manual setup
        console.log('[NginxConfig] Manually copy this to /etc/nginx/sites-available/gilgal.tech:');
        console.log(config);
      }
    } catch (error) {
      console.error('[NginxConfig] Failed to apply nginx config:', error);
      throw error;
    }
  }
}
